#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

async function migrateToInternalStructure() {
  console.log('🔄 Generando metadata y cache para el diccionario interno...');
  
  try {
    const dataDir = path.join(projectRoot, 'public', 'data');
    const internalDir = path.join(dataDir, 'internal', 'v1');
    const internalLangDir = path.join(internalDir, 'dictionary', 'languages');
    
    // Crear estructura de directorios
    await fs.mkdir(internalLangDir, { recursive: true });
    await fs.mkdir(path.join(dataDir, 'internal', 'cache'), { recursive: true });

    // Leer datos existentes
    const dictionaryStats = JSON.parse(
      await fs.readFile(path.join(dataDir, 'dictionary-stats.json'), 'utf-8')
    );
    
    // 1. Crear índice interno del diccionario (la migración de archivos ya no es necesaria)
    console.log('📝 Creando índice interno de diccionario...');
    
    const dictionaryIndex = {
      version: "1.0",
      internal: {
        path: "/internal/v1/dictionary",
        isPublic: false,
        accessType: "import-only"
      },
      meta: {
        totalLanguages: 8,
        totalWords: dictionaryStats.totalUniqueWords,
        totalEntries: dictionaryStats.totalEntries,
        lastUpdated: new Date().toISOString(),
        description: "Diccionario interno multilingüe de himnos obreros"
      },
      languages: [
        { code: "es", name: "Español", nativeName: "Español", wordCount: dictionaryStats.totalUniqueWords, file: "es.json", flag: "🇪🇸" },
        { code: "en", name: "English", nativeName: "English", wordCount: dictionaryStats.totalUniqueWords, file: "en.json", flag: "🇬🇧" },
        { code: "de", name: "Deutsch", nativeName: "Deutsch", wordCount: dictionaryStats.totalUniqueWords, file: "de.json", flag: "🇩🇪" },
        { code: "pt", name: "Português", nativeName: "Português", wordCount: dictionaryStats.totalUniqueWords, file: "pt.json", flag: "🇵🇹" },
        { code: "ru", name: "Русский", nativeName: "Русский", wordCount: dictionaryStats.totalUniqueWords, file: "ru.json", flag: "🇷🇺" },
        { code: "ru-rom", name: "Русский Rom.", nativeName: "Russky Romanized", wordCount: dictionaryStats.totalUniqueWords, file: "ru-rom.json", flag: "🇷🇺" },
        { code: "zh", name: "中文", nativeName: "中文", wordCount: dictionaryStats.totalUniqueWords, file: "zh.json", flag: "🇨🇳" },
        { code: "zh-pinyin", name: "中文 Pinyin", nativeName: "Zhōngwén Pinyin", wordCount: dictionaryStats.totalUniqueWords, file: "zh-pinyin.json", flag: "🇨🇳" }
      ]
    };
    
    await fs.writeFile(
      path.join(internalDir, 'dictionary', 'index.json'),
      JSON.stringify(dictionaryIndex, null, 2),
      'utf-8'
    );
    
    // 2. Crear metadatos del diccionario
    console.log('ℹ️  Creando metadatos del diccionario...');
    const dictionaryMeta = {
      version: "1.0",
      internal: {
        path: "/internal/v1/dictionary/meta",
        isPublic: false
      },
      dictionary: {
        id: "versos-de-protesta-dict",
        name: "Diccionario Interno de Himnos Obreros",
        description: "Vocabulario interno extraído del análisis de himnos revolucionarios",
        methodology: "Extracción automática de vocabulario de canciones obreras históricas",
        scope: "Música obrera, sindicalismo, revolución, resistencia histórica",
        sources: [
          "Himnos anarquistas españoles",
          "Cancionero socialista internacional", 
          "Música de resistencia soviética",
          "Nueva Canción latinoamericana",
          "Canciones obreras alemanas",
          "Protest songs anglófonos",
          "Música revolucionaria china"
        ]
      },
      statistics: dictionaryStats,
      maintenance: {
        lastUpdated: new Date().toISOString(),
        updateFrequency: "on-content-change",
        autoGenerated: true
      }
    };
    
    await fs.writeFile(
      path.join(internalDir, 'dictionary', 'meta.json'),
      JSON.stringify(dictionaryMeta, null, 2),
      'utf-8'
    );
    
    // 3. Crear cache de palabras populares
    console.log('💾 Generando cache de palabras populares...');
    const popularWords = await generatePopularWordsCache(internalDir);
    await fs.writeFile(
      path.join(dataDir, 'internal', 'cache', 'popular-words.json'),
      JSON.stringify(popularWords, null, 2),
      'utf-8'
    );
    
    console.log('\n✅ Proceso de metadata y cache completado');
    console.log('📁 Diccionario interno: public/data/internal/v1/dictionary/');
    console.log('💾 Cache optimizado: public/data/internal/cache/');
    
  } catch (error) {
    console.error('❌ Error en el proceso:', error);
    throw error;
  }
}

async function generatePopularWordsCache(internalDir) {
  const langCodes = ['es', 'en', 'de', 'pt', 'ru', 'zh'];
  const chunksDir = path.join(internalDir, 'dictionary', 'chunks');
  const wordFrequency = new Map();
  
  for (const code of langCodes) {
    try {
      // Asumimos que los chunks siguen un patrón predecible, ej: es-lessons-0-11.json
      // Para hacerlo robusto, leemos el directorio y buscamos el chunk del idioma
      const files = await fs.readdir(chunksDir);
      const chunkFile = files.find(f => f.startsWith(`${code}-`));

      if (!chunkFile) {
        console.warn(`No se encontró chunk para el idioma: ${code}`);
        continue;
      }

      const chunkPath = path.join(chunksDir, chunkFile);
      const chunkData = JSON.parse(await fs.readFile(chunkPath, 'utf-8'));
      
      // La estructura de los chunks es { words: { word: { frequency: X } } }
      Object.entries(chunkData.words || {}).forEach(([word, data]) => {
        const frequency = data.frequency || data.entries?.length || 1;
        wordFrequency.set(word, (wordFrequency.get(word) || 0) + frequency);
      });
    } catch (error) {
      console.warn(`No se pudo procesar el chunk para ${code} para el cache:`, error.message);
    }
  }
  
  const topWords = Array.from(wordFrequency.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 50)
    .map(([word, frequency]) => ({ word, frequency }));
  
  return {
    version: "1.0",
    internal: {
      path: "/internal/cache/popular-words",
      isPublic: false
    },
    meta: {
      totalWords: wordFrequency.size,
      topWords: 50,
      minFrequency: topWords.length > 0 ? topWords[topWords.length - 1].frequency : 0,
      maxFrequency: topWords.length > 0 ? topWords[0].frequency : 0
    },
    words: topWords,
    generated: new Date().toISOString()
  };
}

// Ejecutar si es llamado directamente
if (import.meta.url === `file://${process.argv[1]}`) {
  migrateToInternalStructure().catch(console.error);
}

export { migrateToInternalStructure };